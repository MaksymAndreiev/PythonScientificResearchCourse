import numpy as np
import matplotlib.pyplot as plt

N = 100
x = np.linspace(-1, 1, N + 1)
y = np.linspace(-1, 1, N + 1)
[X, Y] = np.meshgrid(x, y)

x0 = -0.4
y0 = 0.7  # координата першої вершини трапеції
x1 = 0.5
y1 = 0.7  # координата другої вершини трапеції
x2 = -0.7
y2 = -0.4  # координата третьої вершини трапеції
x3 = 0.7
y3 = -0.4  # координата четвертої вершини трапеції

# логічна матриця належності кожної точки
Q1 = Y < y0 + (y1 - y0) / (x1 - x0) * (X - x0)  # зона нижче прямої, яка проходить через точки (x0,y0) і (x1,y1)
Q2 = Y < y0 + (y2 - y0) / (x2 - x0) * (X - x0)  # зона нижче прямої, яка проходить через точки (x0,y0) і (x2,y2)
Q3 = Y < y1 + (y3 - y1) / (x3 - x1) * (X - x1)  # зона вище прямої, яка проходить через точки (x1,y3) і (x2,y3)
Q4 = Y > y2 + (y3 - y2) / (x3 - x2) * (X - x2)  # зона вище прямої, яка проходить через точки (x2,y2) і (x3,y3)
Q = Q1 & Q2 & Q3 & Q4  # Q дорівнює true лише для внутрішніх точок трапеції

# flipud перевертає матрицю для правильного відображення в imshow
B = np.zeros([N + 1, N + 1])  # матриця бажаного розміру, 0 - колір фону (чорний)
B[np.flipud(Q)] = 255  # 255 - колір фігури
cc = 128  # 128 – сірий колір рамки (0 < сс < 255)
n = 5  # товщина рамки в пікселях
B[0:n, :] = cc  # верхня частина рамки
B[-n:, :] = cc  # нижня
B[:, :n] = cc  # ліва
B[:, -n:] = cc  # права
ext = [-1, 1, -1, 1]
plt.imshow(B, cmap='gray', extent=ext)
plt.show()
